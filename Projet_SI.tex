\usepackage{listings}  % Pour le code
\usepackage{xcolor}    % Pour les couleurs
\usepackage{tikz}      % Pour les schémas (optionnel)

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    breaklines=true
}
\section{Envoi de messages chiffrés}

\subsection{Introduction}
Dans notre application de messagerie sécurisée, j'ai implémenté la partie qui permet d'envoyer et de recevoir des messages de manière chiffrée. Mon travail consiste à prendre un message normal (comme "Bonjour"), le transformer en code secret, l'envoyer à un ami, et permettre à cet ami de le déchiffrer pour lire le message original.

\subsection{Le problème à résoudre}
Imaginez que vous voulez envoyer une lettre secrète à votre ami. Si vous l'envoyez normalement, n'importe qui peut la lire en chemin. Notre mission est de :
\begin{itemize}
    \item Mettre le message dans une "boîte magique" qui le rend illisible
    \item Envoyer cette boîte par Internet
    \item Permettre à notre ami (et seulement lui) d'ouvrir la boîte et lire le message
\end{itemize}

\subsection{Comment ça marche ?}

\subsubsection{Étape 1 : Préparer le message}
Quand vous écrivez "Bonjour", l'ordinateur le voit comme des nombres. C'est comme si chaque lettre avait un code secret :
\begin{itemize}
    \item B = 66
    \item o = 111
    \item n = 110
    \item etc.
\end{itemize}

En Python, on fait :
\begin{lstlisting}[language=Python]
message = "Bonjour"
message_bytes = message.encode('utf-8')  # Convertit en nombres
\end{lstlisting}

\subsubsection{Étape 2 : Chiffrer le message}
C'est ici qu'on utilise notre "boîte magique" appelée AES-GCM. Pour chiffrer, on a besoin de deux choses :

\begin{enumerate}
    \item \textbf{Une clé secrète} : C'est comme un mot de passe super compliqué que vous et votre ami partagez (grâce à Diffie-Hellman fait par un autre camarade).
    
    \item \textbf{Un nonce} : C'est un nombre aléatoire qu'on utilise une seule fois. Pourquoi ? Imaginez que vous envoyez "Bonjour" deux fois. Sans nonce, les deux messages chiffrés seraient identiques, et un espion pourrait deviner que c'est le même message. Avec un nonce différent à chaque fois, même message donne un code différent !
\end{enumerate}

Le code :
\begin{lstlisting}[language=Python]
nonce = os.urandom(12)  # Créer un nombre aléatoire
aesgcm = AESGCM(key)    # Préparer la boîte magique
ciphertext = aesgcm.encrypt(nonce, message_bytes, None)
\end{lstlisting}

Après cette opération, "Bonjour" devient quelque chose comme "X7#@9kL2pQ..." totalement illisible !

\subsubsection{Étape 3 : Préparer l'envoi}
On ne peut pas envoyer directement des nombres bizarres par Internet. On les transforme en texte avec Base64 (c'est comme traduire des nombres en lettres normales) :

\begin{lstlisting}[language=Python]
nonce_b64 = base64.b64encode(nonce).decode()
ciphertext_b64 = base64.b64encode(ciphertext).decode()
\end{lstlisting}

Ensuite, on met tout dans un "paquet" JSON (comme une enveloppe) :
\begin{lstlisting}[language=Python]
packet = {
    'nonce': nonce_b64,        # Le nombre aléatoire
    'ciphertext': ciphertext_b64  # Le message chiffré
}
\end{lstlisting}

\subsubsection{Étape 4 : Envoyer via socket}
Un socket, c'est comme un tuyau qui relie deux ordinateurs. On envoie notre paquet dedans :

\begin{lstlisting}[language=Python]
sock.sendall(json.dumps(packet).encode('utf-8') + b'\n')
\end{lstlisting}

\subsection{Recevoir un message}

Quand votre ami reçoit le message, il fait l'inverse :

\subsubsection{Étape 1 : Recevoir le paquet}
\begin{lstlisting}[language=Python]
data = sock.recv(4096)  # Recevoir les données du tuyau
packet = json.loads(data)  # Ouvrir l'enveloppe
\end{lstlisting}

\subsubsection{Étape 2 : Déchiffrer}
Avec la même clé secrète et le nonce reçu, on peut ouvrir la boîte magique :

\begin{lstlisting}[language=Python]
nonce = base64.b64decode(packet['nonce'])
ciphertext = base64.b64decode(packet['ciphertext'])
plaintext_bytes = aesgcm.decrypt(nonce, ciphertext, None)
\end{lstlisting}

\subsubsection{Étape 3 : Lire le message}
On reconvertit les nombres en texte :
\begin{lstlisting}[language=Python]
message = plaintext_bytes.decode('utf-8')  # "Bonjour" !
\end{lstlisting}

\subsection{La sécurité : Pourquoi c'est sûr ?}

\subsubsection{Confidentialité}
Sans la clé secrète, impossible de lire le message. C'est comme si vous aviez un cadenas avec 1 million de milliards de combinaisons possibles. Un espion devrait essayer toutes les combinaisons pendant des millions d'années !

\subsubsection{Authenticité (le tag magique)}
AES-GCM ajoute automatiquement un "tag" au message chiffré. C'est comme un sceau de cire sur une lettre ancienne. Si quelqu'un essaie de modifier le message en chemin, le sceau se casse et on le détecte immédiatement. Le destinataire verra que le message a été trafiqué et refusera de le lire.

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance=2cm]
% Si vous ne pouvez pas faire de schéma, supprimez cette partie
\end{tikzpicture}
\caption{Processus d'envoi et réception de messages chiffrés}
\end{figure}

\subsubsection{Unicité du nonce}
Chaque message utilise un nonce différent. Même si vous envoyez "Bonjour" 100 fois, les 100 messages chiffrés seront tous différents. Un espion ne peut pas deviner que c'est le même message.

\subsection{Schéma récapitulatif}

Voici le voyage d'un message :

\begin{enumerate}
    \item Alice écrit : "Bonjour Bob"
    \item Son ordinateur : "Bonjour Bob" $\rightarrow$ [66, 111, 110, 106, ...]
    \item AES-GCM : [66, 111, ...] + clé + nonce $\rightarrow$ [X7#@9kL2...]
    \item Base64 : [X7#@9kL2...] $\rightarrow$ "eF4jQDlrTDI="
    \item Socket : "eF4jQDlrTDI=" $\rightarrow$ \textit{voyage sur Internet}
    \item Bob reçoit : "eF4jQDlrTDI="
    \item Base64 inverse : "eF4jQDlrTDI=" $\rightarrow$ [X7#@9kL2...]
    \item AES-GCM inverse : [X7#@9kL2...] + clé + nonce $\rightarrow$ [66, 111, ...]
    \item Son ordinateur : [66, 111, ...] $\rightarrow$ "Bonjour Bob"
    \item Bob lit : "Bonjour Bob"
\end{enumerate}

\subsection{Intégration avec le reste du projet}

Mon travail s'intègre avec celui de mes camarades :

\begin{itemize}
    \item \textbf{Diffie-Hellman} : Me fournit la clé secrète partagée
    \item \textbf{Sockets} : Me donne le "tuyau" pour envoyer les données
    \item \textbf{Interface graphique} : Appelle mes fonctions quand l'utilisateur clique sur "Envoyer"
\end{itemize}

\subsection{Tests réalisés}

J'ai testé mon code en créant deux programmes :
\begin{itemize}
    \item Un serveur (qui attend des messages)
    \item Un client (qui envoie des messages)
\end{itemize}

Test effectué :
\begin{enumerate}
    \item Le client envoie "Bonjour"
    \item Le serveur reçoit et affiche "Bonjour"
    \item Le serveur répond "Salut"
    \item Le client reçoit et affiche "Salut"
\end{enumerate}

Résultat : \textbf{Succès !} Les messages arrivent correctement et personne d'autre ne peut les lire.

\subsection{Conclusion}

La partie "envoi de messages chiffrés" est le cœur de notre application. Elle garantit que :
\begin{itemize}
    \item Vos conversations restent privées
    \item Personne ne peut modifier vos messages en secret
    \item Même si quelqu'un intercepte vos données, il ne verra que du charabia
\end{itemize}

C'est comme avoir une machine à écrire des messages secrets que seuls vous et votre ami pouvez lire !